
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Export these constants so they can be referenced elsewhere in the application
export const SUPABASE_URL = "https://fhmvdprcmhkolyzuecrr.supabase.co";
export const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZobXZkcHJjbWhrb2x5enVlY3JyIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDI1MDg5NDIsImV4cCI6MjA1ODA4NDk0Mn0._KsKBT6nK77grg8QEXe4uQbaChgso0qvdSXfQ7OG09o";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Create Supabase client with enhanced reliability configuration
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    realtime: {
      params: {
        eventsPerSecond: 2 // Further reduced to prevent rate limiting issues
      }
    },
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: false,
      storage: localStorage, // Explicitly use localStorage for auth storage
      storageKey: 'supabase-auth-token', // Custom storage key to avoid conflicts
      // Retry configuration for token refresh
      flowType: 'pkce' // More secure flow for authentication
    },
    global: {
      fetch: (...args) => {
        // Enhanced fetch with longer timeout (45 seconds)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 45000);
        
        // Fixed TypeScript error - Create a new options object with signal
        const [url, options = {}] = args;
        const fetchOptions = { 
          ...options, 
          signal: controller.signal 
        };
        
        return fetch(url, fetchOptions).finally(() => {
          clearTimeout(timeoutId);
        });
      }
    }
  }
);

// Set up realtime subscriptions for the main tables with improved error handling
const setupRealtimeSubscriptions = () => {
  try {
    // Check if subscriptions already exist by adding a global flag
    if ((window as any).__supabaseSubscriptionsActive) {
      return [];
    }
    
    (window as any).__supabaseSubscriptionsActive = true;
    
    // Subscribe to analyses table changes
    const analysesChannel = supabase.channel('analyses-realtime')
      .on('postgres_changes', { 
        event: '*', 
        schema: 'public', 
        table: 'analyses' 
      }, payload => {
        console.log('Realtime update from analyses table:', payload);
      })
      .subscribe(status => {
        if (status !== 'SUBSCRIBED') {
          console.warn('Failed to subscribe to analyses table updates:', status);
        }
      });

    // Subscribe to activities table changes with error handling
    const activitiesChannel = supabase.channel('activities-realtime')
      .on('postgres_changes', { 
        event: '*', 
        schema: 'public', 
        table: 'activities' 
      }, payload => {
        console.log('Realtime update from activities table:', payload);
      })
      .subscribe(status => {
        if (status !== 'SUBSCRIBED') {
          console.warn('Failed to subscribe to activities table updates:', status);
        }
      });

    // Subscribe to assessments table changes
    const assessmentsChannel = supabase.channel('assessments-realtime')
      .on('postgres_changes', { 
        event: '*', 
        schema: 'public', 
        table: 'assessments' 
      }, payload => {
        console.log('Realtime update from assessments table:', payload);
      })
      .subscribe(status => {
        if (status !== 'SUBSCRIBED') {
          console.warn('Failed to subscribe to assessments table updates:', status);
        }
      });

    return [analysesChannel, activitiesChannel, assessmentsChannel];
  } catch (error) {
    console.error("Error setting up realtime subscriptions:", error);
    return [];
  }
};

// Initialize realtime subscriptions with retry mechanism and delay
try {
  // Delay initialization of subscriptions to ensure auth is handled first
  setTimeout(() => {
    const initSubscriptions = () => {
      try {
        const channels = setupRealtimeSubscriptions();
        console.log(`Initialized ${channels.length} realtime subscription channels`);
      } catch (error) {
        console.error("Failed to initialize realtime subscriptions:", error);
        // Retry after 10 seconds if it fails
        setTimeout(initSubscriptions, 10000);
      }
    };
    
    initSubscriptions();
  }, 2000); // Delay by 2 seconds to ensure auth is properly initialized first
} catch (error) {
  console.error("Error in subscription initialization block:", error);
}
